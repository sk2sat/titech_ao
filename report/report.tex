\documentclass[10pt,a4j]{jsarticle}

\usepackage[dvipdfmx]{hyperref}
\usepackage{color}
\usepackage{listings,jlisting}
\usepackage[top=30truemm,bottom=15truemm,left=10truemm,right=10truemm]{geometry}

\lstset{
	language={C++},
	backgroundcolor={\color[gray]{.85}},
	frame={tb},
	commentstyle={\color[rgb]{0,0.5,0}},
	keywordstyle={\color[rgb]{1,0,0}},
	stringstyle={\color[rgb]{0,0,1}}
}

\title{\vspace{-4cm}OSが動作するx86エミュレータの開発}
\author{坂本優太}
\date{}

\begin{document}
\maketitle

%\renewcommand{\abstractname}{背景}
%\begin{abstract}
% 僕は，中学生の時に\cite{30days-osdev}をきっかけにコンピュータ・サイエンスの低レイヤの分野に興味を持った．
% また，僕は高校１年生の時にセキュリティ・キャンプ全国大会2016
% \footnote{本における将来の高度IT人材となり得る優れた人材の発掘と育成を目的とした独立行政法人情報処理推進機構(IPA)の事業のメインイベントのうち，2016年に行われたもの．}
% に参加し，低レイヤにより強い興味を持つようになった．
% その後，\cite{learn-x86-by-emu}を読んだが，
% \cite{30days-osdev}で作る簡易的なOSである「はりぼてOS」を動かしたいと思い
% ↑ ここらへんは志望理由の方が良い？
%\end{abstract}

\section{背景}
\cite[30日でできる！ OS自作入門]{30days-osdev}という本をきっかけにプログラミングを初めた僕は，
2016年のセキュリティ・キャンプ全国大会に参加し，よりコンピュータの仕組みに興味を持つようになった．
その後，僕は\cite[自作エミュレータで学ぶx86アーキテクチャ]{learn-x86-by-emu}を読み，
自作OSの動作確認に使っていたエミュレータというプログラムに興味を持つようになった．

エミュレータとは，コンピュータの動作をエミュレート，つまり模倣するプログラムのことで，代表的なものとしては
QEMU\footnote{Fabrice Bellardが中心となって開発しているオープンソースのエミュレータ．
動的バイナリ変換(Dynamic Binary Translation)などの機能を持ち，高速に動作するのが特徴．}
やBochs\footnote{オープンソースのPC/AT互換機のエミュレータ．}などがある．
これらのエミュレータはコンピュータをほぼ正確に模倣するため，
WindowsやLinuxなどの主要なOSや，「はりぼてOS」\footnote{\cite{30days-osdev}で作る小さなOS．}を動かすことができる．

しかし，\cite{learn-x86-by-emu}で作るエミュレータはとても小さく機能もとても少ないものであり，
WindowsやLinuxなどのOSを動かすことができないのはもちろん，「はりぼてOS」のような小さなOSも動かすことはできなかった．

そこで，これらのOSを動かすために必要なエミュレータの機能を考え，独自のエミュレータを開発を初めた．

\section{成果の具体的な内容}

\subsection{エミュレータの基本的な実装}
% コード示してから本のエミュとの相違点説明の方が分かりやすい・書きやすいかも？

\subsection{ディスプレイの実装}

\subsection{セグメンテーションの実装}
% GDT,GDTRの実装
% メモリ保護はまだ

\subsection{テスト環境の整備}
% haribote-os
% make runでバージョン指定してテストできるようにした

%\subsection{実装}
%・16bitと32bit分ける
%・ディスプレイのエミュレーション

%\subsubsection{コンピュータの仕組み}
%エミュレータはコンピュータをエミュレートするプログラムである．
%そのため，エミュレータを作るためにはまずコンピュータの仕組みを知る必要がある．

%現代的なコンピュータを構成する要素には，
%\begin{itemize}
%	\item CPU
%	\item メモリ
%	\item 外部装置
%\end{itemize}
%といったものがある．

%これらの要素のうち，最も重要なのはCPUだ．
%CPUは命令を実行する装置で，
%CPUが実行する命令は，メモリの内部にデータとして保存されている．
%この命令はすべて0と1の２進数で表されており

%コンピュータが起動すると，まず初めにROMに保存されているBIOS
%\footnote{Basic Input/Output System}
%というプログラムが実行が始まる．
%BIOSは，HDDなどの外部記憶からブートローダという小さなプログラムをメモリに読み込み，実行する．
%そして，ブートローダは外部記憶からOSを読み込み，実行する．


%\subsubsection{動作モードの実装}
%「はりぼてOS」が動作するx86アーキテクチャには，
%\begin{itemize}
%	\item 16bitリアルモード
%	\item 32bitプロテクトモード
%	\item 仮想8086モード\footnote{実際にはプロセッサの動作モードではなく，プロテクトモードの属性の１つ．}
%\end{itemize}
%などの複数の動作モードがある．

%16bitモードでは，レジスタやメモリアクセスの単位の上限が16bit
%\footnote{ただし，Operand-Size Prefix・Address-Size Prefixなどがある場合は一時的に32bitになることがある．}
%，32bitモードではそれが32bitになる．

%また，リアルモードは8086プロセッサ互換の動作をするモード，
%プロテクトモードはCPUの保護機能が有効になる動作モードである．

%x86プロセッサでは，電源投入時は16bitリアルモードで動作する．
%しかし，この動作モードでは扱えるメモリアドレスの範囲が小さい上にCPUの保護機能も使うことができない．
%そのため，「はりぼてOS」などのOSは起動すると，まず32bitプロテクトモードへの遷移を行う．

%エミュレータを自作するにあたり初めに参考にした\cite{learn-x86-by-emu}のプログラムでは，
%32bitのリアルモードという仮想的な動作モードしか実装されていなかった．
%そのため，「はりぼてOS」が動作するエミュレータを自作するためには，
%「はりぼてOS」が使用する16bitリアルモードと32bitプロテクトモードの両方を実装する必要があった．

%\cite{learn-x86-by-emu}の実装では，

%\subsubsection{ディスプレイの実装}
%\cite{learn-x86-by-emu}のプログラムには，ディスプレイは一切実装されていない．
%ディスプレイのエミュレーションはエミュレータに無くてはならないものという訳ではない．
%しかし，「はりぼてOS」は入門用ということもあり，GUIに比較的重きを置いたOSである．
%そのため，ディスプレイを実装することは「はりぼてOS」が動作するエミュレータを作る，という目的を鑑みると自然なことだった．

%ディスプレイへの描画は，コンピュータ内部ではメモリ内のVRAM(Video RAM)という特殊な領域への書き込みとして行われている．
%ただし，VRAMはそこまで大きな領域ではないため，VRAMに書き込むデータはRGBのような直接的な色データではなく，事前に設定した色の番号である．

%\begin{lstlisting}
%size_t xsize=320, ysize=200; // 画面サイズ
%size_t x, y; // 座標
%char c = 0; // 色番号
%char *vram = (char*)0xa0000; // VRAM開始アドレス
%for(y=0; y<=ysize; y++){
%	for(x=0; x<=xsize; x++)
%		vram[y * xsize + x] = c; // 座標(x,y)に色番号cをセット
%}
%\end{lstlisting}


\section{サイボウズ・ラボユースでの活動}
%・vmからemuに
%・SDMたべる
%・ログの出力
%・セグメンテーションの実装
%・実行テスト環境

僕はこのx86エミュレータの開発を完全に趣味で行っていた．
そんなとき，2017年の2月に東京で開催されたOSC
\footnote{Open Source Conference Tokyo/Springのこと．}
でサイボウズ・ラボユースという学生支援制度を\cite{30days-osdev}の著者の川合さんに紹介していただいた．
これはサイボウズ・ラボが実施しているもので，メンターの指導と奨励金の支給を受けつつOSSを開発できる制度である．
僕はx86エミュレータの開発をテーマにこの制度に申し込み，書類選考と面接を経て
第７期サイボウズ・ラボユースにラボユース研究生
\footnote{この制度には奨励金の有無のみが異なるラボユース生とラボユース研究生の２つのコースがある．僕はラボユース研究生としては初の採択だったようだ．}として採択された．

ラボユースの期間中，実際に出社できたのは夏休みの間の数回だけのことだったため，
開発は基本的に自宅で行い，メンターの光成さんからリモートでコードレビューを頂いたり，
\cite{read-486}や\cite{effective-cpp}などの書籍を貸して頂いて参考にしたり，というのがラボユースでの主な活動となった．

% 2.3と2.4はラボユース期間中の主な成果

2018年3月，「第7期サイボウズ・ラボユース成果発表会」\footnote{https://blog.cybozu.io/entry/2018/04/05/080000}で成果発表を行い，
僕はサイボウズ・ラボユース研究生を卒業した．

\section{今後の方針}
%・新たな実装
%・実装の見通しの悪さを改善
%・ラムダ式

現在，「はりぼてOS」の全てのバージョンを動作させることを目標として，新たなx86エミュレータを１から開発している．
改良するのではなく作り直す理由は，開発してきたエミュレータの実装は見通しが悪いため，
デバッグや改良にかかる労力が大きすぎると判断したからだ．
新たな実装は同一リポジトリのv2ブランチ\footnote{https://github.com/sk2sat/emu/tree/v2}で行っている．

v2の開発では，設計の見通しの良さ\footnote{"数ヶ月後に見直しても難なく読める"のが目標だ．}と，
実行中のメッセージの分かりやすさをとても重視している．
また，実装にはC++の最新の規格であるC++17を用いている．

v2での最も大きな変更点は，すべての命令の実装にC++のラムダ式を用いていることだ．
これにより，ソースコード\ref{use-lamda}のように，
x86の命令を関数型マクロを使ってとても見た目に分かりやすく実装することができるようになった．

\begin{lstlisting}[caption=ラムダ式を使った命令の実装の一部,label=use-lamda]
#define INSN(opcode, insn, f, block) \
	name[opcode] = #insn; \
	flag[opcode] = f; \
	func[op] = [](CPU &cpu, std::shared_ptr<Memory> memory) block;

	// 命令の実装
	INSN(0x00, add_rm8_r8, ModRM,{ SET_RM8( ADD(GET_RM8(), GET_R8(REG_NUM)) ); });
	INSN(0x04, add_al_imm8,Imm8, { AL = ADD(AL, IMM8); });
	INSN(0x0c, or_al_imm8, Imm8, { AL = OR( AL, IMM8); });
\end{lstlisting}

%通常，エミュレータに求められるのは高速な動作や多くのCPUへの対応だが，
%多くのエミュレータがこれらを優先した結果，ソースコードの可読性を少なからず犠牲にしている側面があるように感じる．
%\footnote{QEMU}
%もちろん，これらの点を蔑ろにしてしまうととても実用には耐えないので，これは仕方のないことだ．
%しかし，\cite{learn-x86-by-emu}のように，コンピュータの仕組みを理解するためにエミュレータを
%そのため，初学者がエミュレータについて学ぼうとした時，参考になるのは書籍\cite{learn-x86-by-emu}ぐらいのも

\section{単独の成果か否か}
単独の成果である．
実装に当たっては書籍\cite{learn-x86-by-emu}のプログラムを参考にはしたものの，設計を変更し，機能も大幅に増えたオリジナルのプログラムとなっている．
設計・実装はすべて１人で行った．
ただし，サイボウズ・ラボユース採択期間中は，ラボユース内のC++勉強会に参加した他，メンターの方に絶版となっていた書籍\cite{read-486}を貸して頂いたり，数回コードレビューを頂いたりした．
コードレビューで指摘されたのはC++の書き方に関するものであり，これによる設計やロジックの変更は生じなかった．
\footnote{コードレビューによる変更は"[FIX] from code review"というコミットで行われている．}


\begin{thebibliography}{99}
	\bibitem{30days-osdev} 30日でできる！ OS自作入門
	\bibitem{learn-x86-by-emu} 自作エミュレータで学ぶx86アーキテクチャ - コンピュータが動く仕組みを徹底理解！
	\bibitem{SDM} Intel® 64 and IA-32 Architectures Software Developer’s Manual vol 1,2,3,4
	\bibitem{read-486} はじめて読む486 - 32ビットコンピュータをやさしく語る
	\bibitem{effective-cpp} Effective C++ - プログラムとデザインを改良するための55項目
\end{thebibliography}

\end{document}
