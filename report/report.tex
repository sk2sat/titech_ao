\documentclass[10pt,a4j]{jsarticle}

\usepackage[dvipdfmx]{hyperref}
\usepackage{color}
\usepackage{listings,jlisting}
\usepackage[top=15truemm,bottom=15truemm,left=10truemm,right=10truemm]{geometry}

\lstset{
	language={C++},
	backgroundcolor={\color[gray]{.85}},
	frame={tb},
	commentstyle={\color[rgb]{0,0.5,0}},
	keywordstyle={\color[rgb]{1,0,0}},
	stringstyle={\color[rgb]{0,0,1}}
}

\title{\vspace{-2cm}OSが動作するx86エミュレータの開発}
\author{坂本優太}
\date{}

\begin{document}
\maketitle

%\renewcommand{\abstractname}{背景}
%\begin{abstract}
% 僕は，中学生の時に\cite{30days-osdev}をきっかけにコンピュータ・サイエンスの低レイヤの分野に興味を持った．
% また，僕は高校１年生の時にセキュリティ・キャンプ全国大会2016
% \footnote{本における将来の高度IT人材となり得る優れた人材の発掘と育成を目的とした独立行政法人情報処理推進機構(IPA)の事業のメインイベントのうち，2016年に行われたもの．}
% に参加し，低レイヤにより強い興味を持つようになった．
% その後，\cite{learn-x86-by-emu}を読んだが，
% \cite{30days-osdev}で作る簡易的なOSである「はりぼてOS」を動かしたいと思い
% ↑ ここらへんは志望理由の方が良い？
%\end{abstract}

\section{背景}
\cite[30日でできる！ OS自作入門]{30days-osdev}という本をきっかけにプログラミングを初めた僕は，
2016年のセキュリティ・キャンプ全国大会に参加し，よりコンピュータの仕組みに興味を持つようになった．
その後，僕は\cite[自作エミュレータで学ぶx86アーキテクチャ]{learn-x86-by-emu}を読み，
自作OSの動作確認に使っていたエミュレータというプログラムに興味を持つようになった．

エミュレータとは，コンピュータの動作をエミュレート，つまり模倣するプログラムのことで，代表的なものとしては
QEMU\footnote{Fabrice Bellardが中心となって開発しているオープンソースのエミュレータ．
動的バイナリ変換(Dynamic Binary Translation)などの機能を持ち，高速に動作するのが特徴．}
やBochs\footnote{オープンソースのPC/AT互換機のエミュレータ．}などがある．
これらのエミュレータはコンピュータをほぼ正確に模倣するため，
WindowsやLinuxなどの主要なOSや，「はりぼてOS」\footnote{\cite{30days-osdev}で作る小さなOS．}を動かすことができる．

しかし，\cite{learn-x86-by-emu}で作るエミュレータはとても小さく機能もとても少ないものであり，
WindowsやLinuxなどのOSを動かすことができないのはもちろん，「はりぼてOS」のような小さなOSも動かすことはできなかった．

そこで，これらのOSを動かすために必要なエミュレータの機能を考え，独自のエミュレータを開発を初めた．
ただし，WindowsやLinuxのような大きなOSを動かすためにはとても多くの機能を実装する必要があるため，
あくまで「はりぼてOS」を動かすことを目標とした．

\section{成果の具体的な内容}

\subsection{エミュレータの設計}
% コード示してから本のエミュとの相違点説明の方が分かりやすい・書きやすいかも？

C++によるエミュレータの実装の基本的な部分は\ref{impl-emu-base}のようになった．
\begin{lstlisting}[caption=エミュレータの基本的な実装,label=impl-emu-base]
typedef union {
	uint32_t reg32;
	uint16_t reg16; // 下位16bit
	struct {
		uint8_t low8, high8;
	};
} Register32; // 32bit register

class Emulator {
	public:
		Register32 CR[5], eflags, eip, reg[8];	// レジスタ
		uint8_t *memory;			// メモリ
	private:
		int bite_mode, memory_size;
}

typedef void instruction_func_t(Emulator *emu); // １つの命令に対応する関数の型
instruction_func_t* instruction16[256];
instruction_func_t* instruction32[256];
\end{lstlisting}
Emulatorクラスには，コンピュータを構成する要素であるCPUやメモリを１つにまとめたものだ．
Register32は32bit長のレジスタを表す共用体で，
メンバを使って下位の8,16bitの領域へのアクセスが行いやすくなっている．
これは実際のレジスタもそのようなアクセスがあるためで，
例えばEAXというレジスタは下位16bitがAX，そのうち上位8bitがAH，下位8bitがALという名前のレジスタとして扱われる．
また，メモリはuint8\_t型の並んだメモリ領域として表現した．

さらに，１つのx86の命令は１つの関数で表現し，それらの関数ポインタの配列．
これは\cite{learn-x86-by-emu}の実装を元にしたものだが，本の実装は32bitのみなので，
複数の動作モードに対応するため，16bitと32bitそれぞれに関数ポインタ配列を用意した．

\subsection{ディスプレイの実装}
QEMUやBochsなどのエミュレータでは，ディスプレイのエミュレートをすることもできる．
エミュレータには必ずしもディスプレイのエミュレートが必要という訳ではない．
しかし，動作目標の「はりぼてOS」は比較的GUIの比重が大きい他，
単純に「はりぼてOS」のUIが自分のエミュレータで見られると嬉しいと思ったため，実装することにした．

ディスプレイは，指定した色で発光するピクセルが解像度の分だけ並んでいるデバイスであり，
描画はそれぞれの座標への色の指定という形で行われている．
この座標と色の設定は，実際にはVRAMというメモリ領域への書き込みによって実現されている．

このVRAMでは1ピクセルに相当するのは1byteとなっている．
これではRGBで色を指定することができないので，ここに書き込むデータはRGBのような色データではなく，
パレットという外部装置に事前に設定しておいた色の番号ということになっている．

これらをエミュレートするため，
\begin{itemize}
	\item 外部装置へのアクセス
	\item パレット
	\item VRAMのデータからRGBデータを生成
	\item RGBデータをウィンドウに表示
\end{itemize}
の実装を行った．

x86では，外部装置へのアクセスはin/out命令で行われる．
これは，デバイスの基本クラスを作り，
in/out命令が実行されると対応するデバイスのクラスの関数が呼ばれるようにすることで表現した．
ディスプレイは１つのデバイスクラスとしてデバイスの基本クラスを継承して作り，
RGBのテーブルとして表現したパレットをout命令で設定できるようにした．

VRAMのデータから実際に描画されるRGBのデータを生成するのは，
画面上の全ての座標においてVRAMから読み取った色番号に対応する色データをパレットから取得して設定することで実装した．

\begin{lstlisting}
unsigned char* Display::Draw(){
	for(int x=0;x<scrnx;x++){
		for(int y=0;y<scrny;y++){
			int i = y*scrnx + x;
			char n= vram[i]; // (x,y)の色番号
			img[i*3  ] = palette[n*3  ];
			img[i*3+1] = palette[n*3+1];
			img[i*3+2] = palette[n*3+2];
		}
	}
	return img;
}
\end{lstlisting}

生成したRGBデータをウィンドウに表示する部分は，
オープンソースでマルチプラットフォーム対応のGUIライブラリであるfreeglutを使用した．

\subsection{セグメンテーションの実装\label{impl-segmentation}}
% GDT,GDTRの実装
% メモリ保護はまだ

\subsection{テスト環境の整備\label{impl-test-env}}
% haribote-os
% make runでバージョン指定してテストできるようにした

\section{サイボウズ・ラボユースでの活動}
%・vmからemuに
%・SDMたべる
%・ログの出力
%・セグメンテーションの実装
%・実行テスト環境

僕はこのx86エミュレータの開発を完全に趣味で行っていた．
そんなとき，2017年の2月に東京で開催されたOSC
\footnote{Open Source Conference Tokyo/Springのこと．}
でサイボウズ・ラボユースという学生支援制度を\cite{30days-osdev}の著者の川合さんに紹介していただいた．
これはサイボウズ・ラボが実施しているもので，メンターの指導と奨励金の支給を受けつつOSSを開発できる制度である．
僕はx86エミュレータの開発をテーマにこの制度に申し込み，書類選考と面接を経て
第７期サイボウズ・ラボユースにラボユース研究生
\footnote{この制度には奨励金の有無のみが異なるラボユース生とラボユース研究生の２つのコースがある．僕はラボユース研究生としては初の採択だったようだ．}として採択された．

ラボユースの期間中，実際に出社できたのは夏休みの間の数回だけのことだったため，
開発は基本的に自宅で行い，メンターの光成さんからリモートでコードレビューを頂いたり，
\cite{read-486}や\cite{effective-cpp}などの書籍を貸して頂いて参考にしたり，というのがラボユースでの主な活動となった．

\ref{impl-segmentation}と\ref{impl-test-env}はラボユース期間中の主な成果

2018年3月，「第7期サイボウズ・ラボユース成果発表会」\footnote{\url{https://blog.cybozu.io/entry/2018/04/05/080000}}で成果発表を行い，
僕はサイボウズ・ラボユース研究生を卒業した．

\section{今後の方針}
%・新たな実装
%・実装の見通しの悪さを改善
%・ラムダ式

現在，「はりぼてOS」の全てのバージョンを動作させることを目標として，新たなx86エミュレータを１から開発している．
改良するのではなく作り直す理由は，開発してきたエミュレータの実装は見通しが悪いため，
デバッグや改良にかかる労力が大きすぎると判断したからだ．
新たな実装は同一リポジトリのv2ブランチ\footnote{\url{https://github.com/sk2sat/emu/tree/v2}}で行っている．

v2の開発では，設計の見通しの良さ\footnote{"数ヶ月後に見直しても難なく読める"のが目標だ．}と，
実行中のメッセージの分かりやすさをとても重視している．
また，実装にはC++の最新の規格であるC++17を用いている．

v2での最も大きな変更点は，すべての命令の実装にC++のラムダ式を用いていることだ．
これにより，ソースコード\ref{use-lamda}のように，
x86の命令を関数型マクロを使ってとても見た目に分かりやすく実装することができるようになった．

\begin{lstlisting}[caption=ラムダ式を使った命令の実装の一部,label=use-lamda]
#define INSN(opcode, insn, f, block) \
	name[opcode] = #insn; \
	flag[opcode] = f; \
	func[op] = [](CPU &cpu, std::shared_ptr<Memory> memory) block;

	// 命令の実装
	INSN(0x00, add_rm8_r8, ModRM,{ SET_RM8( ADD(GET_RM8(), GET_R8(REG_NUM)) ); });
	INSN(0x04, add_al_imm8,Imm8, { AL = ADD(AL, IMM8); });
	INSN(0x0c, or_al_imm8, Imm8, { AL = OR( AL, IMM8); });
\end{lstlisting}

%通常，エミュレータに求められるのは高速な動作や多くのCPUへの対応だが，
%多くのエミュレータがこれらを優先した結果，ソースコードの可読性を少なからず犠牲にしている側面があるように感じる．
%\footnote{QEMU}
%もちろん，これらの点を蔑ろにしてしまうととても実用には耐えないので，これは仕方のないことだ．
%しかし，\cite{learn-x86-by-emu}のように，コンピュータの仕組みを理解するためにエミュレータを
%そのため，初学者がエミュレータについて学ぼうとした時，参考になるのは書籍\cite{learn-x86-by-emu}ぐらいのも

\section{単独の成果か否か}
単独の成果である．
実装に当たっては書籍\cite{learn-x86-by-emu}のプログラムを参考にはしたものの，設計を変更し，機能も大幅に増えたオリジナルのプログラムとなっている．
設計・実装はすべて１人で行った．
ただし，サイボウズ・ラボユース採択期間中は，ラボユース内のC++勉強会に参加した他，メンターの方に絶版となっていた書籍\cite{read-486}を貸して頂いたり，数回コードレビューを頂いたりした．
コードレビューで指摘されたのはC++の書き方に関するものであり，これによる設計やロジックの変更は生じなかった．
\footnote{コードレビューによる変更は"[FIX] from code review"というコミットで行われている．}

成果は全てGitHub上で公開している．
該当するリポジトリは以下の３つである．
\begin{itemize}
	\item \url{https://github.com/sk2sat/vm}			当初作っていたエミュレータ
	\item \url{https://github.com/sk2sat/emu}			ラボユース申し込み後に作り直したエミュレータ
	\item \url{https://github.com/sk2sat/haribote-os}	「はりぼてOS」実行テスト用のプロジェクト
\end{itemize}

\begin{thebibliography}{99}
	\bibitem{30days-osdev} 30日でできる！ OS自作入門
	\bibitem{learn-x86-by-emu} 自作エミュレータで学ぶx86アーキテクチャ - コンピュータが動く仕組みを徹底理解！
	\bibitem{SDM} Intel® 64 and IA-32 Architectures Software Developer’s Manual vol 1,2,3,4
	\bibitem{read-486} はじめて読む486 - 32ビットコンピュータをやさしく語る
	\bibitem{effective-cpp} Effective C++ - プログラムとデザインを改良するための55項目
\end{thebibliography}

\end{document}
